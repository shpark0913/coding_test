## 정렬 알고리즘 개요

정렬(Sorting)
- 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
- 정렬 알고리즘은 이진 탐색(Binary Search)의 전처리 과정이니 제대로 공부할 것
- 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 학습할 것

## 선택 정렬
- 데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 것
- '매번 가장 작은 것을 선택'한다는 의미에서 **선택 정렬(Selection Sort)** 알고리즘이라 부름
- 시간복잡도 : O(N^2)
  - 따라서 뒤에서 학습할 알고리즘과 비교했을 때 매우 비효율적
- 특정 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 잦음
  - 선택 정렬 소스코드 형태에 익숙해져야 함

## 삽입 정렬
- 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?
- 선택 정렬과 비교
  - 구현 난이도가 높음
  - 실행 시간 측면에서 더 효율적
- 필요할 때만 위치를 바꾸므로 **데이터가 거의 정렬되어 있을 때** 굉장히 효율적
  - 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않음
- 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 *삽입 정렬(Insertion Sort)**이라고 부름
  - 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정
  - 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입됨
- 시간복잡도 : O(N^2)
  - 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작함
  - 최선의 경우 O(N)
- 퀵 정렬과 비교
  - 보통은 삽입 정렬이 비효율적
  - 정렬이 거의 되어 있는 상황이라면 퀵 정렬보다 강력

## 퀵 정렬
- 기준 데이터를 설정하고, 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?
- 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작함 
- 피벗(Pivot)이 사용됨 (피벗이란, 큰 숫자와 작은 숫자를 교환할 때 교환하기 위한 기준)
- 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 함
- 가장 대표적인 분할 방식인 호어 분할 방식을 기준으로 퀵 정렬을 학습하겠음
- 퀵 정렬은 재귀 함수 형태로 작성했을 때 구현이 매우 간결해짐. 그렇다면 종료 조건 있어야!!
  - 퀵 정렬이 끝나는 조건은? -> 현재 리스트의 데이터 개수가 1개인 경우
- 시간복잡도 : O(NlogN)

## 계수 정렬
- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
- 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리, 항상 사용은 불가

## key 매개변수
- sorted()나 sort()를 이용할 때는 key 매개변수를 입력으로 받을 수 있음
- key 값으로는 하나의 함수가 들어가야 하며, 이는 정렬 기준이 됨
- 예를 들어 리스트의 데이터가 튜플로 구성되어 있을 때, 각 데이터의 두 번째 원소를 기준으로 설정해 보자
  - -> 6-9.py